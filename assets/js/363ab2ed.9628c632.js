"use strict";(self.webpackChunkgephi_documentation=self.webpackChunkgephi_documentation||[]).push([[1176],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=p(n),g=o,c=u["".concat(s,".").concat(g)]||u[g]||h[g]||r;return n?a.createElement(c,l(l({ref:t},d),{},{components:n})):a.createElement(c,l({ref:t},d))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,l=new Array(r);l[0]=u;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:o,l[1]=i;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7262:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const r={id:"scripting-plugin",title:"Scripting Plugin"},l=void 0,i={unversionedId:"Manuals/scripting-plugin",id:"Manuals/scripting-plugin",title:"Scripting Plugin",description:"This introduction tutorial will guide you through the features of the Gephi Scripting Plugin. The plugin originated as a GSoC 2011 project, in a joint proposal with the GUESS project which aimed at porting the Gython language as a console plugin for Gephi.",source:"@site/docs/02_Manuals/Scripting-Plugin.md",sourceDirName:"02_Manuals",slug:"/Manuals/scripting-plugin",permalink:"/gephi-documentation/Manuals/scripting-plugin",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/02_Manuals/Scripting-Plugin.md",tags:[],version:"current",frontMatter:{id:"scripting-plugin",title:"Scripting Plugin"},sidebar:"tutorialSidebar",previous:{title:"Localization",permalink:"/gephi-documentation/Manuals/localization"},next:{title:"Community",permalink:"/gephi-documentation/category/community"}},s={},p=[{value:"Background",id:"background",level:2},{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2},{value:"Accessing the Graph",id:"accessing-the-graph",level:3},{value:"Nodes",id:"nodes",level:3},{value:"Edges",id:"edges",level:3},{value:"The Additional Operators",id:"the-additional-operators",level:3},{value:"Modifying the Graph",id:"modifying-the-graph",level:3},{value:"Applying Filters",id:"applying-filters",level:3},{value:"Running Layouts",id:"running-layouts",level:3},{value:"Exporting",id:"exporting",level:3},{value:"Using Third-Party Libraries",id:"using-third-party-libraries",level:3},{value:"Clearing the console",id:"clearing-the-console",level:3},{value:"Additional Examples",id:"additional-examples",level:2},{value:"Generating Random Graphs",id:"generating-random-graphs",level:3},{value:"Depth-First Search",id:"depth-first-search",level:3},{value:"Finding a Minimum Spanning Tree",id:"finding-a-minimum-spanning-tree",level:3},{value:"Finding a Shortest Path",id:"finding-a-shortest-path",level:3},{value:"Feedback",id:"feedback",level:2},{value:"Reporting Bugs",id:"reporting-bugs",level:3},{value:"Source Code",id:"source-code",level:3}],d={toc:p};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This introduction tutorial will guide you through the features of the Gephi Scripting Plugin. The plugin originated as a ",(0,o.kt)("a",{parentName:"p",href:"https://gephi.org/2011/gsoc-mid-term-scripting-plugin"},"GSoC 2011 project"),", in a joint proposal with the ",(0,o.kt)("a",{parentName:"p",href:"http://graphexploration.cond.org/"},"GUESS")," project which aimed at porting the Gython language as a console plugin for Gephi."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://cloud.githubusercontent.com/assets/197285/5621763/951d8a5e-9539-11e4-9a4f-9f925060ddb9.png",alt:"console"})),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"A sample scripting console session.")),(0,o.kt)("h2",{id:"background"},"Background"),(0,o.kt)("p",null,"The Scripting Plugin provides a console in which the user can execute Python commands and manipulate the graph. The plugin allows users to do tasks that are usually repetitive and tedious on the GUI in a very easy way, by making the graph accessible through a concise scripting language called Gython."),(0,o.kt)("p",null,"Gython was originally conceived by the GUESS project and consists of a Domain-Specific Language for manipulating graph structures, implemented over Python. Among the main features of the language are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Nodes and edges are exported to the scripting language as regular objects. Attributes of these objects can be accessed directly (e.g. v1.color)."),(0,o.kt)("li",{parentName:"ul"},"Additional operators for handling graph structures, like the A -> B operator, which selects all the edges that connect the nodes (or set of nodes) A and B."),(0,o.kt)("li",{parentName:"ul"},'Filters can be easily created with the comparison operators on nodes or edges attributes (e.g., dept == "IT" builds a filter that selects all nodes in the IT department).'),(0,o.kt)("li",{parentName:"ul"},'The attributes of a set of nodes can be set easily with a single command (e.g., (dept == "IT").color = blue sets the color of all the nodes in the IT department to blue).')),(0,o.kt)("h2",{id:"installation"},"Installation"),(0,o.kt)("p",null,"The Scripting Plugin can be installed through the Gephi's Tools/Plug-ins menu:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Go to the Tools > Plug-ins menu on Gephi's user interface."),(0,o.kt)("li",{parentName:"ol"},"Open the Available Plugins tab."),(0,o.kt)("li",{parentName:"ol"},'Click the "Reload Catalog" button, to make sure you have an up-to-date catalog.'),(0,o.kt)("li",{parentName:"ol"},'Select the "Scripting Plugin" on the list and click the Install button.')),(0,o.kt)("p",null,"After installation, the plugin can be accessed through the left slide on Gephi's UI (as shown on figure) or through the Window > Console menu. "),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://cloud.githubusercontent.com/assets/197285/5621764/9525a69e-9539-11e4-9232-f70fd38fe917.png",alt:"console-location"})),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Location of the Scripting Console on Gephi's UI.")),(0,o.kt)("h2",{id:"usage"},"Usage"),(0,o.kt)("p",null,"Since the plugin's language is based on Python, it is desirable that you have some basic Python knowledge to work with the plugin. Although, you should be able to follow this quick start guide even if you have never programmed before."),(0,o.kt)("p",null,"After installing the plugin, you can open the Console through the Window menu from Gephi's user interface. The Console window works similarly to a command line window that you would find in most operating systems: you type commands into this console and hit enter to have them evaluated."),(0,o.kt)("p",null,"If you type there a simple arithmetic expression like 2 + 2, you should get the following output on the console:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> 2 + 2\n4\n")),(0,o.kt)("p",null,"The next sections assume that you have a graph opened on the current workspace. You can use any of the ",(0,o.kt)("a",{parentName:"p",href:"http://wiki.gephi.org/index.php/Datasets"},"Gephi sample datasets")," or any graph of your own. Note that there is one console session for each workspace. This means that you can only access the current workspace through the console session."),(0,o.kt)("h3",{id:"accessing-the-graph"},"Accessing the Graph"),(0,o.kt)("p",null,"The main graph object can be accessed through the reserved variable name ",(0,o.kt)("inlineCode",{parentName:"p"},"g")," (or through the alias ",(0,o.kt)("inlineCode",{parentName:"p"},"graph"),"). This object has a few methods and attributes. The most important ones are probably the attributes ",(0,o.kt)("inlineCode",{parentName:"p"},"nodes")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"edges"),", which are respectively the set of the graph's nodes and edges."),(0,o.kt)("p",null,"Let's say that, for example, you would like to see the set of nodes and the set of edges of the graph:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> g.nodes\nset([v1, v2, v3, v4, v5, v6, v7, v8])\n>>> g.edges\nset([e1, e2, e3, e4, e5])\n")),(0,o.kt)("p",null,"Based on the output above, we can conclude that this graph has 8 nodes and 5 edges. To get the number of nodes and edges through code, you can use the len built-in function from Python:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> len(g.nodes)\n8\n>>> len(g.edges)\n5\n")),(0,o.kt)("p",null,'As you can see, each node and edge of the graph can also be accessed through reserved variables. You can access the nodes simply by prefixing the node id with "v", while the edges can be accessed by prefixing the edge id with "e". Gython names them based on their internal identification number on the Gephi toolkit.'),(0,o.kt)("p",null,'The graph object "g" has three methods to look if the graph is directed, undirected or mixed: isDirected, isUndirected and isMixed:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> g.isDirected()\nFalse\n>>> g.isUndirected()\nTrue\n")),(0,o.kt)("h3",{id:"nodes"},"Nodes"),(0,o.kt)("p",null,"To access a node from the console, just prefix the node's id with v. If you're unsure of the node's id, you can check the Data Laboratory or just see the entire list of nodes by calling \"g.nodes\" in the console."),(0,o.kt)("p",null,'The nodes objects (v1, v2, etc) make it very easy to read/write attributes to nodes. For instance, if you have a node attribute column called "gender" you can access it directly for both reading and writing, for example:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'>>> v42.gender = "female"\n>>> v42.gender\n"female"\n')),(0,o.kt)("p",null,"Topological attributes and other default attribute columns are also available from the node object attributes:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Attribute"),(0,o.kt)("th",{parentName:"tr",align:null},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Read-Only"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"color"),(0,o.kt)("td",{parentName:"tr",align:null},'java.awt.Color (or simply "color")'),(0,o.kt)("td",{parentName:"tr",align:null},"No"),(0,o.kt)("td",{parentName:"tr",align:null},"The color of the node")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"size"),(0,o.kt)("td",{parentName:"tr",align:null},"Float"),(0,o.kt)("td",{parentName:"tr",align:null},"No"),(0,o.kt)("td",{parentName:"tr",align:null},"The size of the node")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"label"),(0,o.kt)("td",{parentName:"tr",align:null},"String"),(0,o.kt)("td",{parentName:"tr",align:null},"No"),(0,o.kt)("td",{parentName:"tr",align:null},"The label of the node")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"x"),(0,o.kt)("td",{parentName:"tr",align:null},"Float"),(0,o.kt)("td",{parentName:"tr",align:null},"No"),(0,o.kt)("td",{parentName:"tr",align:null},"The x coordinate of the node")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"y"),(0,o.kt)("td",{parentName:"tr",align:null},"Float"),(0,o.kt)("td",{parentName:"tr",align:null},"No"),(0,o.kt)("td",{parentName:"tr",align:null},"The y coordinate of the node")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"fixed"),(0,o.kt)("td",{parentName:"tr",align:null},"Boolean"),(0,o.kt)("td",{parentName:"tr",align:null},"No"),(0,o.kt)("td",{parentName:"tr",align:null},"True if the node's position is fixed")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"indegree"),(0,o.kt)("td",{parentName:"tr",align:null},"Integer"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes"),(0,o.kt)("td",{parentName:"tr",align:null},"The number of incoming edges incident to node")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"outdegree"),(0,o.kt)("td",{parentName:"tr",align:null},"Integer"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes"),(0,o.kt)("td",{parentName:"tr",align:null},"The number of outgoing edges incident to node")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"degree"),(0,o.kt)("td",{parentName:"tr",align:null},"Integer"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes"),(0,o.kt)("td",{parentName:"tr",align:null},"The degree of the node")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"neighbors"),(0,o.kt)("td",{parentName:"tr",align:null},"Set"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes"),(0,o.kt)("td",{parentName:"tr",align:null},"A list of the nodes that are connected to the node")))),(0,o.kt)("p",null,"So, if you want to set v1's color to red, you can run the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> v1.color = red\n")),(0,o.kt)("p",null,"To get the set of neighbors of a given node:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> v1.neighbors\nset([v5, v7])\n")),(0,o.kt)("p",null,"Or to get the degree of a node:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> v1.degree\n2\n")),(0,o.kt)("p",null,"Creating new attribute columns is straightforward. If you try to set a node's attribute that does not exist, its corresponding attribute column will be created automatically."),(0,o.kt)("h3",{id:"edges"},"Edges"),(0,o.kt)("p",null,'Accessing edges through the scripting console is done in a similar way as nodes, but through the reserved variable names prefixed with "e". You can also access your edge\'s attributes with the same notation as nodes. Let\'s say you have a edge attribute column called "relationship":'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'>>> e4.relationship = "friends"\n>>> e4.relationship\n"friends"\n')),(0,o.kt)("p",null,"Just like nodes, edges also have some default attributes available:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Attribute"),(0,o.kt)("th",{parentName:"tr",align:null},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Read-Only"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"color"),(0,o.kt)("td",{parentName:"tr",align:null},'java.awt.Color (or simply "color")'),(0,o.kt)("td",{parentName:"tr",align:null},"No"),(0,o.kt)("td",{parentName:"tr",align:null},"The color of the edge")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"weight"),(0,o.kt)("td",{parentName:"tr",align:null},"Float"),(0,o.kt)("td",{parentName:"tr",align:null},"No"),(0,o.kt)("td",{parentName:"tr",align:null},"The color of the edge")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"label"),(0,o.kt)("td",{parentName:"tr",align:null},"String"),(0,o.kt)("td",{parentName:"tr",align:null},"No"),(0,o.kt)("td",{parentName:"tr",align:null},"The label of the edge")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"directed"),(0,o.kt)("td",{parentName:"tr",align:null},"Boolean"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes"),(0,o.kt)("td",{parentName:"tr",align:null},"Indicates if this edge is directed")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"source"),(0,o.kt)("td",{parentName:"tr",align:null},"Node"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes"),(0,o.kt)("td",{parentName:"tr",align:null},"The source of this edge")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"target"),(0,o.kt)("td",{parentName:"tr",align:null},"Node"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes"),(0,o.kt)("td",{parentName:"tr",align:null},"The target of this edge")))),(0,o.kt)("p",null,"These attributes work just like the nodes' attributes. So, if you want to see which is the source node of the edge e3, you would just run the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> e3.source\nv2\n")),(0,o.kt)("h3",{id:"the-additional-operators"},"The Additional Operators"),(0,o.kt)("p",null,"If compared to Python, the Gython grammar has four additional operators for selecting edges. These operators work as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"v1 <-> v2: selects the undirected edge connecting nodes v1 and v2."),(0,o.kt)("li",{parentName:"ul"},"v1 -> v2 (or v2 <- v1): selects the directed edge from node v1 to node v2."),(0,o.kt)("li",{parentName:"ul"},"v1 ? v2: selects any edges connecting nodes v1 and v2.")),(0,o.kt)("p",null,"These operators can be applied to sets of nodes too. So, for instance, if you want to get all the directed edges from nodes v3, v4 or v5 to any of the graph's nodes, you could get them by doing the following (recall that the nodes attribute from the main graph (g) corresponds to the set of all the graph's nodes):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> set([v3, v4, v5]) -> g.nodes\nset([e4, e7, e9, e10])\n")),(0,o.kt)("p",null,"Now let's say you want to update an attribute of these edges. For example, to set the weight of these edges to 2.5, we could assign the resulting set of edges to a new variable and modify the attribute as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> our_edges = set([v3, v4, v5]) -> g.nodes\n>>> our_edges.weight = 2.5\n")),(0,o.kt)("p",null,"Or, we could simply do the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> (set([v3, v4, v5]) -> g.nodes).weight = 2.5\n")),(0,o.kt)("h3",{id:"modifying-the-graph"},"Modifying the Graph"),(0,o.kt)("p",null,'Modifying the graph through the console is a straighforward process. The main graph object "g" has the following methods for modifying the graph structure:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"addNode()"),": creates a new node on the graph."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"addDirectedEdge(source, target)"),": creates a directed edge between the source and target nodes."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"addUndirectedEdge(source, target)"),": creates an undirected edge between the source and target nodes."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"addEdge(source, target)"),": equivalent to ",(0,o.kt)("inlineCode",{parentName:"li"},"addUndirectedEdge(source, target)"),".")),(0,o.kt)("p",null,"Using these methods, you could create two new nodes and connect them with an undirected edge by running the following commands:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> g.addNode()\nv1\n>>> g.addNode()\nv2\n>>> g.addUndirectedEdge(v1, v2)\ne1\n")),(0,o.kt)("p",null,"Note that the addNode method tells us the id of the newly created node, while the same thing happens to the addUndirectedEdge method."),(0,o.kt)("p",null,"The addNode method also has a very handy feature, for setting attributes while you're creating nodes. Let's create a new node with the green color and some given coordinates:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> g.addNode(color = green, x = -32, y = 16)\nv3\n")),(0,o.kt)("p",null,"To delete nodes and edges from the graph you can use the del statement like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> del v2\n>>> del e3\n")),(0,o.kt)("h3",{id:"applying-filters"},"Applying Filters"),(0,o.kt)("p",null,"The scripting plugin makes building complex filters a really simple operation. All the nodes and edges' attributes are available through global variables on the console (even the nodes' topology attributes like degree, indegree and outdegree). To build filters, you only have to use these attributes with one of the comparison operators: ",(0,o.kt)("inlineCode",{parentName:"p"},"==, !=, >, <, >=")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"<="),"."),(0,o.kt)("p",null,"For instance, if you would like to create a filter that matches only nodes with degree greater than 5, you could type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> degree > 5\n<org.gephi.scripting.wrappers.GyFilter object at 0x2>\n")),(0,o.kt)("p",null,'You can build more complex filters with the & and | operators, which correspond to the AND and OR logical operators. For instance, if you have a node attribute "age" and you would like to match nodes older than 21 that have at least one neighbor (degree >= 1):'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> (age > 21) & (degree >= 1)\n")),(0,o.kt)("p",null,'Or if you would like to match nodes that are into the "HR" or the "IT" departments:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'>>> (dept == "HR") | (dept == "IT")\n')),(0,o.kt)("p",null,"You can put together as many filters as you want. Don't forget the parenthesis around the filters, as they're necessary because of Python's operator precedence."),(0,o.kt)("p",null,'Even though the above examples teach you how to build filters, that code is pretty much useless until now. Let\'s create a new filter again (based on the first example) and, this time, apply it to the main graph. To do that, you have to use the filter method from the main graph object ("g" or "graph"). The filter method is really simple, it applies the filter that is passed as parameter and returns a subgraph that is the result of the filtering operation:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> mySubGraph = g.filter(degree > 5)\n")),(0,o.kt)("p",null,'Note that the resulting subgraph object has the same methods and attributes as the main graph object "g". This means that you can get the nodes and edges through the nodes and edges attributes or even apply more filters to your subgraph through the filter method:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> mySubGraph.nodes\nset([v1, v5])\n>>> myOtherSubGraph = mySubGraph.filter(age > 42)\n")),(0,o.kt)("p",null,'The only difference between a subgraph object and the main graph object "g" is that the addNode and addEdge methods are not available on the subgraph. Since the nodes attribute from the subgraph object is just a regular Python set, you can check if a given node is in a subgraph by typing:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> v1 in mySubGraph.nodes\nTrue\n>>> v2 in mySubGraph.nodes\nFalse\n")),(0,o.kt)("p",null,'To see a subgraph in the Graph View component of Gephi, you can just assign it to the "visible" global variable or call the setVisible function:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> visible = mySubGraph\n>>> setVisible(myOtherSubGraph)\n")),(0,o.kt)("p",null,"Finally, to add a filter to the Filters User Interface on Gephi, you just have to use the addFilter function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'>>> addFilter((dept == "HR") & (age == 42), name = "42 year-old people from the HR department")\n')),(0,o.kt)("p",null,'Now you should see a new filter called "42 year-old people from the HR department" on the UI. Note that the "name" parameter to the addFilter function is optional. '),(0,o.kt)("h3",{id:"running-layouts"},"Running Layouts"),(0,o.kt)("p",null,"There are two global functions that are used to running and stopping layouts execution from the console: runLayout and stopLayout."),(0,o.kt)("p",null,"The function runLayout takes a single argument: a reference to the layout builder of the layout that is going to be executed. If you would like to run the ForceAtlas 2 algorithm, you would have to import it's builder and then run it, for instance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> import org.gephi.layout.plugin.forceAtlas2.ForceAtlas2Builder\n>>> runLayout(org.gephi.layout.plugin.forceAtlas2.ForceAtlas2Builder)\n")),(0,o.kt)("p",null,"Of course, this is not good looking and not even easy to remember. To make this process more intuitive, the scripting plugin comes with aliases to the layout builders of all the layout algorithms that come with Gephi:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"YifanHu"),(0,o.kt)("li",{parentName:"ul"},"YifanHuProportional"),(0,o.kt)("li",{parentName:"ul"},"ForceAtlas"),(0,o.kt)("li",{parentName:"ul"},"ForceAtlas2"),(0,o.kt)("li",{parentName:"ul"},"FruchtermanReingold"),(0,o.kt)("li",{parentName:"ul"},"LabelAdjust"),(0,o.kt)("li",{parentName:"ul"},"YifanHuMultiLevel"),(0,o.kt)("li",{parentName:"ul"},"RandomLayout"),(0,o.kt)("li",{parentName:"ul"},"ClockwiseRotate"),(0,o.kt)("li",{parentName:"ul"},"CounterClockwiseRotate"),(0,o.kt)("li",{parentName:"ul"},"Contract"),(0,o.kt)("li",{parentName:"ul"},"Expand")),(0,o.kt)("p",null,"So, to run the ForceAtlas 2 algorithm, we can just execute the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> runLayout(ForceAtlas2)\n")),(0,o.kt)("p",null,"If you want to run an algorithm for a given number of iterations, the runLayout function also has an optional argument called iters. Let's use this argument to run 500 iterations of the Yifan-Hu algorithm:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> runLayout(YifanHu, iters = 500)\n")),(0,o.kt)("p",null,"To force stop the execution of a layout algorithm that is being currently executed, you have to call the stopLayout function, which takes no arguments:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> stopLayout()\n")),(0,o.kt)("h3",{id:"exporting"},"Exporting"),(0,o.kt)("p",null,"Since there aren't any customization options yet, exporting through the console is really straightforward. Everything is done just by calling the export function with the output file name as argument, for example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'>>> exportGraph("/home/user/output.pdf")\n')),(0,o.kt)("p",null,"Or if you want to export to a png image file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'>>> exportGraph("/home/user/output.png")\n')),(0,o.kt)("h3",{id:"using-third-party-libraries"},"Using Third-Party Libraries"),(0,o.kt)("p",null,'There\'s a lot of Python/Jython code available on the web. Using third-party libraries with the Scripting Plugin is very simple, you just have to put the library in the "scripts" directory under the ',(0,o.kt)("a",{parentName:"p",href:"https://github.com/gephi/gephi/wiki/Troubleshooting#where-are-user-files"},"Gephi user directory"),". On Linux, this path should be something like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"/home/luiz/.gephi/0.8.1/dev/scripts\n")),(0,o.kt)("p",null,"Or like this, on Windows 7:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"C:\\Users\\Luiz\\AppData\\Roaming\\.gephi\\0.8.1\\dev\\scripts\n")),(0,o.kt)("p",null,"After putting the library on that path, you should be able to import its modules as described on the respective library's documentation. Remember that the Scripting Plugin is based on Jython, therefore some more complex Python libraries are not guaranteed to work properly without some code modifications."),(0,o.kt)("h3",{id:"clearing-the-console"},"Clearing the console"),(0,o.kt)("p",null,"If you want to clear the console you can do so like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'console.text_pane.setText("")\n')),(0,o.kt)("h2",{id:"additional-examples"},"Additional Examples"),(0,o.kt)("p",null,"This section provides some interesting and more complex examples of the scripting plugin. Feel free to share your snippets here!"),(0,o.kt)("p",null,"To run these code snippets, you should save the code in a .py file and call the execfile() function with the full path to it. For instance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'>>> execfile("/home/user/prim.py")\n')),(0,o.kt)("p",null,"Relative paths work too, but they have to be relative to the run path (which is the path in which Gephi is installed, most of the times). This works for Windows too, but remember to escape the backslash characters from the file path like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'>>> execfile("C:\\\\Users\\\\user\\\\Documents\\\\prim.py")\n')),(0,o.kt)("h3",{id:"generating-random-graphs"},"Generating Random Graphs"),(0,o.kt)("p",null,"The following code snippet builds a random graph with 50 nodes and 50% of chance of an edge existing between two given nodes. After building the graph, it runs the Force Atlas layout algorithm for 500 iterations."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"import random\n \n# create nodes\nfor i in range(50):\n    g.addNode()\n \n# create edges randomly\nfor u in g.nodes:\n    for v in g.nodes:\n        if random.random() < 0.5:\n            g.addEdge(u, v)\n \n# run force atlas layout\nrun_layout(ForceAtlas, iters=500)\n")),(0,o.kt)("h3",{id:"depth-first-search"},"Depth-First Search"),(0,o.kt)("p",null,"The following code snippet shows how to traverse the graph by doing a ",(0,o.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Depth-first_search"},"Depth-First Search")," that starts from the node v1. Once the DFS algorithm visits a node, it will change its color to red."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"visited = set([])\n \ndef dfs(u):\n    visited.insert(u)\n \n    u.color = red\n \n    for v in u.neighbors:\n        if v not in visited:\n            dfs(v)\n \ndfs(v1)\n")),(0,o.kt)("h3",{id:"finding-a-minimum-spanning-tree"},"Finding a Minimum Spanning Tree"),(0,o.kt)("p",null,"This code snippet shows an implementation of the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Prim%27s_algorithm"},"Prim's Algorithm")," for finding the total weight of a minimum spanning tree on a given undirected graph."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"# the set of nodes that are not yet in the MST\nU = g.nodes\n \n# D[v] = the cost of adding node v to the MST\nD = {}\nfor v in U:\n    D[v] = float('inf')\n \n# initially, the cost of adding some node to the MST is zero\nD[iter(U).next()] = 0\n \n# the total cost of the MST\ntotal = 0.0\n \n# while there are nodes to add to the tree\nwhile len(U) > 0:\n    # find the cheapest node that can be added\n    node = iter(U).next()\n    for v in U:\n        if D[v] < D[node]:\n            node = v\n \n    # add it to the MST\n    total += D[node]\n    U.remove(node)\n \n    # update the costs for the neighbor nodes\n    for e in node <-> U:\n        D[e.target] = min(D[e.target], e.weight)\n \n# print the total weight of the MST\nprint \"The total weight of the MST is %f\" % total\n")),(0,o.kt)("h3",{id:"finding-a-shortest-path"},"Finding a Shortest Path"),(0,o.kt)("p",null,"The following code finds a shortest path between two given nodes on the graph by using the ",(0,o.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm"},"Bellman-Ford algorithm"),". It also highlights a shortest path between the nodes on the graph, by coloring it red and graying out nodes and edges that are not in the path."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"def shortest_path(start, end):\n    # initialize distances and predecessor edges\n    dist, prev = {}, {}\n    for v in g.nodes:\n        dist[v], prev[v] = float('inf'), None\n    dist[start] = 0\n \n    # Bellman-Ford algorithm\n    for i in range(len(g.nodes)):\n        for e in g.edges:\n            if dist[e.target] > dist[e.source] + e.weight:\n                dist[e.target] = dist[e.source] + e.weight\n                prev[e.target] = e\n \n    # color all the nodes and edges as RGB 200, 200, 200\n    for v in g.nodes:\n        v.color = color(200, 200, 200)\n    for e in g.edges:\n        e.color = color(200, 200, 200)\n \n    # highlight a shortest path with the red color (if one exists)\n    if dist[end] < float('inf'):\n        e = prev[end]\n        end.color = red\n        while e != None:\n            e.color = red\n            e.source.color = red\n            e = prev[e.source]\n \n    # return the total weight of the path (distance)\n    return dist[end]\n")),(0,o.kt)("p",null,"Note that this code only defines a function called shortest_path. Therefore, after loading this code with execfile, you'll have to call the function from the console like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},">>> shortest_path(v1, v3)\n")),(0,o.kt)("h2",{id:"feedback"},"Feedback"),(0,o.kt)("h3",{id:"reporting-bugs"},"Reporting Bugs"),(0,o.kt)("p",null,"If you find a bug, please report it to our ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gephi/gephi-plugins/issues?labels=python-scripting-plugin"},"Issues Tracker")," at GitHub. Just make sure to assign the python-scripting-plugin label to the issue you're reporting."),(0,o.kt)("h3",{id:"source-code"},"Source Code"),(0,o.kt)("p",null,"The source code is available on the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gephi/gephi-plugins/tree/python-scripting-plugin"},"python-scripting-plugin branch")," of the gephi-plugins repository on GitHub."))}h.isMDXComponent=!0}}]);