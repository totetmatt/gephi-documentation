"use strict";(self.webpackChunkgephi_documentation=self.webpackChunkgephi_documentation||[]).push([[4158],{3905:(e,t,o)=>{o.d(t,{Zo:()=>p,kt:()=>d});var n=o(7294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var u=n.createContext({}),c=function(e){var t=n.useContext(u),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},p=function(e){var t=c(e.components);return n.createElement(u.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},s=n.forwardRef((function(e,t){var o=e.components,r=e.mdxType,a=e.originalType,u=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),s=c(o),d=r,h=s["".concat(u,".").concat(d)]||s[d]||m[d]||a;return o?n.createElement(h,i(i({ref:t},p),{},{components:o})):n.createElement(h,i({ref:t},p))}));function d(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=o.length,i=new Array(a);i[0]=s;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<a;c++)i[c]=o[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,o)}s.displayName="MDXCreateElement"},1663:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var n=o(7462),r=(o(7294),o(3905));const a={id:"how-to-execute-a-metric-over-time",title:"How to execute a metric over time"},i=void 0,l={unversionedId:"Toolkit/How_to_code_with_the_toolkit/how-to-execute-a-metric-over-time",id:"Toolkit/How_to_code_with_the_toolkit/how-to-execute-a-metric-over-time",title:"How to execute a metric over time",description:"NOTE//gephi.org/gephi/0.9.2/apidocs",source:"@site/docs/07_Toolkit/How_to_code_with_the_toolkit/How-to-execute-a-metric-over-time.md",sourceDirName:"07_Toolkit/How_to_code_with_the_toolkit",slug:"/Toolkit/How_to_code_with_the_toolkit/how-to-execute-a-metric-over-time",permalink:"/gephi-documentation/Toolkit/How_to_code_with_the_toolkit/how-to-execute-a-metric-over-time",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/07_Toolkit/How_to_code_with_the_toolkit/How-to-execute-a-metric-over-time.md",tags:[],version:"current",frontMatter:{id:"how-to-execute-a-metric-over-time",title:"How to execute a metric over time"},sidebar:"tutorialSidebar",previous:{title:"How to compute a metric",permalink:"/gephi-documentation/Toolkit/How_to_code_with_the_toolkit/how-to-compute-a-metric"},next:{title:"How to export graph",permalink:"/gephi-documentation/Toolkit/How_to_code_with_the_toolkit/how-to-export-graph"}},u={},c=[],p={toc:c};function m(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"NOTE: this example is not up to date with latest Gephi 0.9.2 It needs to be reviewed. Now, dynamics are part of the core Graph API ",(0,r.kt)("a",{parentName:"strong",href:"https://gephi.org/gephi/0.9.2/apidocs"},"https://gephi.org/gephi/0.9.2/apidocs"))),(0,r.kt)("p",null,"This ",(0,r.kt)("a",{parentName:"p",href:"/Toolkit/how-to-build-the-toolkit"},"Toolkit Example")," is part of the toolkit-demos project, that can be downloaded from the ",(0,r.kt)("a",{parentName:"p",href:"http://gephi.org/toolkit"},"website"),"."),(0,r.kt)("hr",null),(0,r.kt)("p",null,"This demo main aim is to show how to execute a metric on a dynamic graph. It does the following steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create a project and a workspace, it is mandatory."),(0,r.kt)("li",{parentName:"ul"},"Generate a random graph into a container."),(0,r.kt)("li",{parentName:"ul"},"Append this container to the main graph structure."),(0,r.kt)("li",{parentName:"ul"},"Create a ",(0,r.kt)("em",{parentName:"li"},"date")," column (a simple ",(0,r.kt)("inlineCode",{parentName:"li"},"INT")," between 1990 and 2010) and set random values for each node."),(0,r.kt)("li",{parentName:"ul"},"Use the Data Laboratory merge strategy to convert this column to a real time interval column."),(0,r.kt)("li",{parentName:"ul"},"Get a ",(0,r.kt)("inlineCode",{parentName:"li"},"DynamicGraph")," and count the number of nodes for each year. That shows how to get the subgraph for a particular period."),(0,r.kt)("li",{parentName:"ul"},"Put the result into a dynamic data structure, that shows how to store result associated to a particular period."),(0,r.kt)("li",{parentName:"ul"},"Create a ",(0,r.kt)("inlineCode",{parentName:"li"},"InOutDegree")," metric, execute it for each year and collect the results in a dynamic data structure.")),(0,r.kt)("p",null,"Instead of generating a random 'static' graph and add a fake date column, a dynamic network can be imported with the GEXF file format."),(0,r.kt)("p",null,"The demo shows how to get a ",(0,r.kt)("inlineCode",{parentName:"p"},"DynamicGraph")," instance, and get sub graphs for a particular time period. Note that the dynamic graph maintains only one sub graph at one time, so keeping multiple ",(0,r.kt)("inlineCode",{parentName:"p"},"Graph")," instances for further analysis won't work."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'//Init a project - and therefore a workspace\nProjectController pc = Lookup.getDefault().lookup(ProjectController.class);\npc.newProject();\nWorkspace workspace = pc.getCurrentWorkspace();\n\n//Generate a new random graph into a container\nContainer container = Lookup.getDefault().lookup(ContainerFactory.class).newContainer();\nRandomGraph randomGraph = new RandomGraph();\nrandomGraph.setNumberOfNodes(500);\nrandomGraph.setWiringProbability(0.005);\nrandomGraph.generate(container.getLoader());\n\n//Append container to graph structure\nImportController importController = Lookup.getDefault().lookup(ImportController.class);\nimportController.process(container, new DefaultProcessor(), workspace);\n\n//Add a fake \'Date\' column to nodes\nAttributeModel attributeModel = Lookup.getDefault().lookup(AttributeController.class).getModel();\nAttributeColumn dateColumn = attributeModel.getNodeTable().addColumn("date", AttributeType.INT);\n\n//Add a random date to all nodes - between 1990 and 2010\nGraphModel graphModel = Lookup.getDefault().lookup(GraphController.class).getModel();\nGraph graph = graphModel.getGraph();\nRandom random = new Random();\nfor (Node n : graph.getNodes()) {\n   Integer randomDataValue = new Integer(random.nextInt(21) + 1990);\n   n.getNodeData().getAttributes().setValue(dateColumn.getIndex(), randomDataValue);\n}\n \n//Use the Data laboratory merge strategy to convert this Integer column to the TimeInterval column\nAttributeColumnsMergeStrategiesController dataLabController = Lookup.getDefault().lookup(AttributeColumnsMergeStrategiesController.class);\ndataLabController.mergeNumericColumnsToTimeInterval(attributeModel.getNodeTable(), dateColumn, null, 1990, 2010);\n\n//Use the DynamicModel dynamic graph factory\nDynamicModel dynamicModel = Lookup.getDefault().lookup(DynamicController.class).getModel();\nDynamicGraph dynamicGraph = dynamicModel.createDynamicGraph(graph);\n\n//Get the number of nodes for each period of one year - and store it in a proper data structure\nDynamicInteger numberofNodes = new DynamicInteger();\nfor (int i = 1990; i < 2009; i++) {\n    int low = i;\n    int high = i + 1;\n    Graph subGraph = dynamicGraph.getSnapshotGraph(low, high);\n    int count = subGraph.getNodeCount();\n    //DynamicInteger is immutable\n    numberofNodes = new DynamicInteger(numberofNodes, new Interval<Integer>(low, high, count));\n}\n\n//Get all intervals and print values\nSystem.out.println("Number of nodes:");\nfor (Interval<Integer> interval : numberofNodes.getIntervals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY)) {\n    int low = (int) interval.getLow();\n    int high = (int) interval.getHigh();\n    System.out.println(low + "-" + high + "  ->  " + interval.getValue());\n}\n \n//Create a InOutDegree metric to get the average degree for each time interval\nInOutDegree inOutDegree = new InOutDegree();\n \n//Compute the metric for each subgraph and put result in a DynamicDouble\nDynamicDouble averageDegree = new DynamicDouble();\nfor (int i = 1990; i < 2009; i++) {\n    int low = i;\n    int high = i + 1;\n    Graph subGraph = dynamicGraph.getSnapshotGraph(low, high);\n    inOutDegree.execute(subGraph, attributeModel);\n    double result = inOutDegree.getAverageDegree();\n    averageDegree = new DynamicDouble(averageDegree, new Interval<Double>(low, high, result));\n}\n \n//Get all intervals and print values\nSystem.out.println("Average degree:");\nfor (Interval<Double> interval : averageDegree.getIntervals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY)) {\n    int low = (int) interval.getLow();\n    int high = (int) interval.getHigh();\n    System.out.println(low + "-" + high + "  ->  " + interval.getValue());\n}\n')))}m.isMDXComponent=!0}}]);